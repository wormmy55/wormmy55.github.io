# -*- coding: utf-8 -*-
"""group_1_dynamic_chart.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F5BXRLJSYFL4CuKP7vLg5wWpmysR_tTD

#Group 1
Name: Salma Chaaban <br>
Student number: 301216551 <br>
Name: Hodan Ahmed Yusuf<br>
Student number: 301226634<br>
Name: Jonathan Au<br>
Student number: 300827701<br>
Name: Landon Essex<br>
Student number: 301349452<br>
Name: Michael Angelo Cabalinan <br>
Student number: 300924795 <br>
COMP 216 - assignment 10

#Lab 12 â€“ Display a Dynamic Line Chart.
You will display a line chart of a dynamic dataset. It is advised that you start with lab 11 and add the capability to update the display You will add the capability of dynamically display a change dataset. We will build a GUI to display a set of values. You will display the values using both a line chart and a bar chart on the same app. Most of the coding will come from <b>Week_10_lab_11_DisplayChart.docx</b>. You will make the following addition to your solution of lab11:
1.	Create an additional method that will be executed in a thread. This method will do the following in an infinite loop:
o	Remove the first item in the list of values
o	Add a new random value to the end of the list
o	Call the method to display list on the canvas
o	Sleep for a short while (0.5 of a second).
2.	In the initUI() method do the following at the end:
o	You may remove the Entry widget. This is not used in this application.
o	Create a thread and set the target to the method in step 1
o	Set the daemon property of the above thread to True. This will terminate the thread when the Gui closes.
o	Start the thread.
3.	Modify the method that draws the rectangle and line to just draw lines.

##Rubrics

Marks breakdown<br>
[reasonable class design]  - init method, task broken down logically 3/4<br>
[code readability]  - pythonic names for variables and methods 3/3<br>
[initUIb method]  - initialize the ui 3/3<br>
[use generator]  -  1/1<br>
[thread method]  - mut run the updateGUI method is a thread 6/6<br>
[update Gui]  - remove existing line and draw new ones 8/8<br>
[gui]  - proper title, legend, ticks on axis 3/3<br>
[aesthetics]  3/3<br>
[Deductions]  - bad programming practices 0<br>
[Total]  30/30<br>
"""

#Taken from lab 9
import tkinter as tk
from tkinter import ttk, messagebox
import random
import math
import threading
import time
import numpy as np

class DataGenerator:
    def __init__(self, root, ymin=0, ymax=60, daily_mean=19, daily_amps=[1.2, 2, 3, 2.5, 3.5], stddev=2.4):
        self.root = root
        self.ymin = ymin
        self.ymax = ymax
        self.daily_mean = daily_mean
        self.daily_amps = daily_amps
        self.daily_freqs = [2.5 * math.pi / 100, 1 * math.pi / 100, 2 * math.pi / 100, 1.2 * math.pi / 100, 1.8 * math.pi / 100]
        self.stddev = stddev
        self.t = 0
        self.values = self.generate_values(20)
        self.last_line = None  # Store the ID of the last drawn line

    def initUI(self):
        self.root.title("Dynamic Display")

        self.chart_label = ttk.Label(self.root, text="Temperature", font=("Helvetica"))
        self.chart_label.pack(pady=(20, 0))

        self.canvas = tk.Canvas(self.root, width=500, height=250)
        self.canvas.pack()

        self.data_range_label = ttk.Label(self.root, text="", font=("Helvetica", 12))
        self.data_range_label.pack(pady=10)

        
        # Create a thread and set the target to the method in step 1
        thread = threading.Thread(target=self.update_data_continuously)
        thread.daemon = True # Set the daemon property of the above thread to True
        thread.start() # Start the thread

        self.draw_line()
        
    

    # method that will be executed in a thread
    def update_data_continuously(self):
        while True:
            self.values.pop(0) # Remove the first item in the list of values
            daily_variation = sum([amp * math.sin(self.t * freq) for amp, freq in zip(self.daily_amps, self.daily_freqs)])
            new_value = self.daily_mean + daily_variation + random.gauss(0, self.stddev * 2)
            self.values.append(new_value) # Add a new random value to the end of the list
            self.t += 1
            self.draw_line()  # Call the method to display list on the canvas
            time.sleep(0.5)  # Sleep for a short while (0.5 of a second)

    def generate_values(self, count):
        data = []
        num_points = 500
        for _ in range(num_points):
            daily_variation = sum([amp * math.sin(self.t * freq) for amp, freq in zip(self.daily_amps, self.daily_freqs)])
            value = self.daily_mean + daily_variation + random.gauss(0, self.stddev * 2)
            data.append(value)
            self.t += 1
        return data

    def draw_line(self):
        self.canvas.delete("all")
        num_values = len(self.values)
        
        x_start = 40
        y_start = 220
        x_step = 410 / (num_values - 1)
        y_scale = 4
        
        smoothed_values = self.smooth_data(self.values)  # Smoothing the data
        
        for i in range(num_values - 1):
            x1 = x_start + i * x_step
            x2 = x_start + (i + 1) * x_step
            y1 = y_start - smoothed_values[i] * y_scale
            y2 = y_start - smoothed_values[i + 1] * y_scale
            self.canvas.create_line(x1, y1, x2, y2, fill="red", width=2)

    def smooth_data(self, data, window_size=5):
        smoothed_data = np.convolve(data, np.ones(window_size) / window_size, mode='valid')
        return np.concatenate(([data[0]] * (len(data) - len(smoothed_data)), smoothed_data))
            

if __name__ == "__main__":
    root = tk.Tk()
    app = DataGenerator(root)
    app.initUI()
    root.mainloop()