# -*- coding: utf-8 -*-
"""Assignment 2_Pizza - Jonathan Au - 300827701.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hArxxgXsrtrcAyXi_WNv8RQFE6WLK4Jw

Name: Jonathan Au <br>
Student ID: 300827701 <br>
Date: January 28, 2024 <br>

# Specifications for the Pizza class
The implementation of this class is almost simplistic! All of the methods (except two) are only single code statements. My class implementation is only 30 lines of code.

## Class attributes

Remember that class members do not have a "self" prefix and are accessed with the class name and the dot operator.
<br>
1. Valid sizes for pizza contained in a collection at the class level.
You get to figure out the type of collection to store the sizes below.
Valid sizes are small, medium, large and x-large.<br><br>
2. Another class level collection having the prices for each valid size.
You get to decide on the type of collection to store the prices below.
Prices are small: $6.49, medium: $8.49, large: $10.49, x-large: $13.49.

## Constructor
Instance methods have an implicit first argument "self".
<br>
3. A constructor that takes a default size of medium and topping of a list of cheese that does the following:
<br><br>a. Set the first argument size to the instance attribute size. Size must be verified. This can be done by setting the size property.
<br><br>b. Creates an instance attribute a list with the second argument. If the second argument is missing, a single cheese topping is inserted in the list.


##Instance Methods
Instance methods have an implicit first argument "self".
<br>
4.  A method that takes an argument of type list of strings. It adds topping to the list of pizza toppings.
5.  Implement the __str__() method to return a formatted string. Examine the output from the test harness for clues on how to implement this method.


##Instance Properties
Instance properties have an implicit first argument "self".
6.	A property that returns the price of the pizza.
<br>a.	Price is based on the size as well as the number of toppings.
See spec#2 for cost based on size. Each topping cost an additional $0.50 each.
7.	A property that returns the size of the pizza.
8.	A property that sets the size of the pizza.
<br>a.	Size must be verified. A ValueError exception is raised if the size is invalid.


##Instance Attributes
All of the following Instance attributes are initialized in the constructor from the values of the argument. Notice the __ prefix to make is private.
<br>
9.	__size is a str that stores the size of this object. This is initialized in the constructor. It is mutated by the property in #8. It is returned in #7. It is used in #6 to calculate the cost of the pizza.
10.	__toppings a list of string that represents the toppings for this object. This is initialized in the constructor. It is mutated in the add() method and is used in #6 to calculate the cost of the pizza.
"""

class Pizza:
  valid_size = ['small', 'medium', 'large', 'x-large']
  size_price = dict(zip(valid_size,[6.49, 8.49, 10.49, 13.49]))

  def __init__(self, s = 'medium', t = ['cheese']):
    self.size = s
    self.__toppings = t

  def add(self, topping):
    self.__toppings += topping
    self.__price__()
    return self.__toppings

  def __str__(self):
    return f'{self.size} pizza with {self.__toppings} for ${self.__price__()}'

  def __price__(self):
    self.price = Pizza.size_price[self.size] + (len(self.__toppings) * 0.50)
    return self.price

#can't get this to work. any thoughts?
class ValueError(Exception):
  def __init__(self):
    self.size in Pizza.valid_size
  def __str__(self):
    return f'ERROR: {self.size} is not a valid size for a pizza'

"""# Test Harness

*I think there was an error on the test harness as the original code was <br>
p.add(toppings=toppings)
"""

print(f'Creating a default pizza')
p = Pizza()
print(p)

toppings = 'cheese olive'.split()
print(f'\nAdding topping: {toppings}')
p.add(toppings)
print(p)

print(f'\nCreating a new pizza')
p = Pizza('large', 'cheese pepper'.split())
print(p)

toppings = ['pineapple', 'mushroom']
print(f'\nAdding topping: {toppings}')
p.add(toppings)
print(p)

size = 'x-large'
p.size = size
print(f'\nChanging order size to {size}')
print(p)

size = 'gigantic'
print(f'\nChanging order size to {size}')
try:
  p.size = size
except ValueError as err:
  print(err)

"""# Resulting output



Creating a default pizza<br>
medium pizza with ['cheese'] for $8.99
<br><br>

Adding topping: ['cheese', 'olive']<br>
medium pizza with ['cheese', 'cheese', 'olive'] for $9.99
<br><br>

Creating a new pizza<br>
large pizza with ['cheese', 'pepper'] for $11.49
<br><br>

Adding topping: ['pineapple', 'mushroom']<br>
large pizza with ['cheese', 'pepper', 'pineapple', 'mushroom'] for $12.49
<br><br>

Changing order size to x-large<br>
x-large pizza with ['cheese', 'pepper', 'pineapple', 'mushroom'] for $15.49
<br><br>

Changing order size to gigantic<br>
ERROR: gigantic is not a valid size for a pizza<br>

# Personal code testing
"""

#price = {'small':6.49, 'medium':8.49, 'large':10.49, 'x-large':13.49}
price1 = dict(zip(['small', 'medium', 'large', 'x-large'],[6.49, 8.49, 10.49, 13.49]))
p = Pizza()
#print(p.size)
print(p)
p = Pizza('large', 'cheese peppers'.split())
#size = 'small'
print(p)
toppings = 'cheese peppers'.split()
#topp = ['cheese'] + toppings
p.add(toppings)
#print(p.size)
#print(len(p.toppings))
#print(p.price[p.size])
#print(p.toppings)
print(p)

toppings = 'cheese olive'.split()
print(f'\nAdding topping: {toppings}')
p.add(toppings)
print(p)
size = 'gigantic'
try:
  p.size = size
except ValueError as err:
  print(err)